"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const APIError_1 = require("../../types/APIError");
const Errors = require("../../util/errors");
const MongooseError = require("mongoose/lib/error");
function errorHandler(err) {
    const errors = [];
    if (err.errors) {
        Object.keys(err.errors).forEach(errKey => {
            const thisError = err.errors[errKey];
            const errorFormatted = (() => {
                if (err.name === 'ValidationError') {
                    if (thisError.kind === 'required') {
                        return Errors.missingField({
                            detail: thisError.message,
                            rawError: thisError
                        });
                    }
                    if (APIError_1.default.isDisplaySafe(thisError.reason)) {
                        return APIError_1.default.fromError(thisError.reason);
                    }
                    else if (thisError.reason && !(thisError.reason instanceof MongooseError)) {
                        return Errors.invalidFieldValue({
                            detail: `Invalid value for path "${thisError.path}"`,
                            rawError: thisError.reason
                        });
                    }
                    return Errors.invalidFieldValue({
                        detail: thisError.message,
                        rawError: thisError
                    });
                }
                return APIError_1.default.fromError(thisError);
            })();
            errors.push(errorFormatted);
        });
    }
    else if (err.name === 'MongoError' && err.code === 11000) {
        errors.push(Errors.uniqueViolation({
            rawError: err,
            code: 11000
        }));
    }
    else {
        errors.push(err);
    }
    throw errors;
}
exports.errorHandler = errorHandler;
function toMongoCriteria(constraintOrPredicate) {
    const mongoOperator = "$" +
        (constraintOrPredicate.operator === 'neq'
            ? 'ne'
            : constraintOrPredicate.operator);
    const mongoField = (constraintOrPredicate.field === 'id'
        ? '_id'
        : constraintOrPredicate.field);
    switch (constraintOrPredicate.operator) {
        case "and":
        case "or":
            return !constraintOrPredicate.value.length
                ? {}
                : {
                    [mongoOperator]: constraintOrPredicate.value.map(toMongoCriteria)
                };
        case "eq":
            return { [mongoField]: constraintOrPredicate.value };
        default:
            return {
                [mongoField]: {
                    [mongoOperator]: constraintOrPredicate.value
                }
            };
    }
}
exports.toMongoCriteria = toMongoCriteria;
function resourceToDocObject(resource, typePathFn) {
    const res = Object.assign({}, resource.attrs, (typePathFn ? typePathFn(resource.typePath) : {}));
    Object.keys(resource.relationships).forEach(key => {
        res[key] = resource.relationships[key].unwrapDataWith(it => it.id);
    });
    return res;
}
exports.resourceToDocObject = resourceToDocObject;
